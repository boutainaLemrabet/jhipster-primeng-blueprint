<%#
 Copyright 2013-2020 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%>
<%_
const query = generateEntityQueries(relationships, entityInstance, dto);
const hasRelationshipQuery = relationships && relationships.some(r => r.ownerSide);
const hasPaginationRelationship = relationships && relationships.some(r => r.ownerSide && r.pagination != 'no');
const hasValidationRule = fields.some(field =>
        field.fieldValidate && (
                field.fieldValidateRules.includes('required') ||
                field.fieldValidateRules.includes('minlength') ||
                field.fieldValidateRules.includes('maxlength') ||
                field.fieldValidateRules.includes('min') ||
                field.fieldValidateRules.includes('max') ||
                field.fieldValidateRules.includes('pattern')
        )
);
const hasRequiredRelationship = relationships.some(relationship => relationship.relationshipRequired);
const isValidatorsRequired = hasValidationRule || hasRequiredRelationship;
_%>
import { Component, OnInit } from '@angular/core';
import { HttpResponse<% if (relationships.filter(r => r.ownerSide).length) { %>, HttpErrorResponse<% } %> } from '@angular/common/http';
import { FormBuilder,<%_ if (isValidatorsRequired) { _%> Validators<%_ } _%> } from '@angular/forms';
import { ActivatedRoute } from '@angular/router';
import { Observable } from 'rxjs';
<%_ if (hasPaginationRelationship) { _%>
import { lazyLoadEventToServerQueryParams } from '../../core/request/request-util';
import { LazyLoadEvent } from 'primeng/api';
<%_ } _%>
import { I<%= entityAngularName %> } from '../../shared/model/<%= entityModelFileName %>.model';
<%_
if ( jpaMetamodelFiltering) {
    const enumOptions = [];
    fields.forEach(field => {
        if (field.fieldIsEnum && !enumOptions.includes(field.fieldType)) {
            enumOptions.push(field.fieldType);
        }
    });
    enumOptions.forEach(e => { _%>
import { <%= e %>, <%= _.snakeCase(e).toUpperCase() %>_ARRAY } from '../../shared/model/enumerations/<%= _.kebabCase(e) %>.model';
    <%_ }); _%>
<%_ } _%>
import { <%= entityAngularName %>Service } from './<%= entityFileName %>.service';
<%_ if (hasRelationshipQuery || fieldsContainBlob) { _%>
import { MessageService } from 'primeng/api';
<%_ } _%>
<%_ if (fieldsContainBlob) { _%>
import { DataUtils } from '../../core/util/data-util.service';
<%_ } _%>
<%_
Object.keys(differentRelationships).forEach(key => {
    if (differentRelationships[key].some(rel => rel.relationshipType === 'many-to-one' || rel.relationshipType === 'one-to-one' && rel.ownerSide === true || rel.relationshipType === 'many-to-many' && rel.ownerSide === true)) {
        const uniqueRel = differentRelationships[key][0];
        if (uniqueRel.otherEntityAngularName !== entityAngularName) {
            if (isBuiltInUser(uniqueRel.otherEntityAngularName)) {
_%>
import { IUser } from '../../core/user/user.model';
import { UserService } from '../../core/user/user.service';
<%_
            } else {
_%>
import { I<%= uniqueRel.otherEntityAngularName %> } from '../../shared/model/<%= uniqueRel.otherEntityModelName %>.model';
import { <%= uniqueRel.otherEntityAngularName %>Service } from '../<%= uniqueRel.otherEntityPath %>/<%= uniqueRel.otherEntityFileName %>.service';
<%_ function generateRelationshipsImports(relationship) {
    return `import { I${relationship.otherEntity.name} } from '../../shared/model/${relationship.otherEntity.entityModelFileName}.model';
    import { ${relationship.otherEntity.name}Service } from '../${relationship.otherEntity.entityFolderName}/${relationship.otherEntity.entityFileName}.service';
    ${relationship.otherEntity.relationships.filter(r => r.id).map(r => generateRelationshipsImports(r)).join('')}`;
} _%>
<%_ uniqueRel.otherEntity.relationships.filter(r => r.id).map(r => {_%>
    <%- generateRelationshipsImports(r) -%>
<%_ }) _%>
<%_
            }
        }
    }
});
_%>

@Component({
    selector: '<%= jhiPrefixDashed %>-<%= entityFileName %>-update',
    templateUrl: './<%= entityFileName %>-update.component.html'
})

export class <%= entityAngularName %>UpdateComponent implements OnInit {
<%_ if (!entity.primaryKey.ids[0].autoGenerated || entity.primaryKey.derived) { _%>
    edit = false;
<%_ } _%>
    isSaving = false;
<%_ function generateOptions(relationship) {
    return `${relationship.relationshipName}Options?: I${relationship.otherEntity.name}[] = undefined;
    ${relationship.otherEntity.relationships.filter(r => r.id).map(r => generateOptions(r)).join('')}`;
} _%>
<%_ relationships.filter(r => r.ownerSide).forEach(r => { _%>
    <%- generateOptions(r) -%>
<%_ }) _%>

<%_ for ( idx in fields ) { _%>
    <%_ if (fields[idx].fieldIsEnum) { _%>
    <%= fields[idx].fieldName %>Options = <%= _.snakeCase(fields[idx].fieldType).toUpperCase() %>_ARRAY.map((s: <%=fields[idx].fieldType%>) => ({ label: s.toString(), value: s }));
    <%_ } else if (['byte[]', 'ByteBuffer'].includes(fields[idx].fieldType) && fields[idx].fieldTypeBlobContent !== 'text') { _%>
    <%= fields[idx].fieldName %>File?: File;
    <%_ } _%>
<%_ } _%>

    editForm = this.fb.group({
<%_ for (idx in fields) {
    const fieldName = fields[idx].fieldName;
    const fieldType = fields[idx].fieldType;
    const fieldTypeBlobContent = fields[idx].fieldTypeBlobContent; _%>
        <%= fieldName %>: [<% if (fields[idx].fieldValidate === true) { %>null,[<% if (fields[idx].fieldValidateRules.includes('required')) { %>Validators.required,<% } %><% if (fields[idx].fieldValidateRules.includes('minlength')) { %>Validators.minLength(<%= fields[idx].fieldValidateRulesMinlength %>),<% } %><% if (fields[idx].fieldValidateRules.includes('maxlength')) { %>Validators.maxLength(<%= fields[idx].fieldValidateRulesMaxlength %>),<% } %><% if (fields[idx].fieldValidateRules.includes('min')) { %>Validators.min(<%= fields[idx].fieldValidateRulesMin %>),<% } %><% if (fields[idx].fieldValidateRules.includes('max')) { %>Validators.max(<%= fields[idx].fieldValidateRulesMax %>),<% } %><% if (fields[idx].fieldValidateRules.includes('pattern')) { %>Validators.pattern('<%= fields[idx].fieldValidateRulesPattern %>'),<% } %>]<% } %>],
    <%_ if (['byte[]', 'ByteBuffer'].includes(fieldType) && fieldTypeBlobContent !== 'text') { _%>
        <%= fieldName %>ContentType: [],
    <%_ } _%>
<%_ } _%>
<%_ function generateRelationshipForm(relationship) {
    return `${relationship.relationshipName}: this.fb.group({
    ${relationship.otherEntity.fields.filter(f => f.id).map(f => `${f.fieldName}: [null, [Validators.required]],`).join('\n')}
    ${relationship.otherEntity.relationships.filter(r => r.id).map(r => generateRelationshipForm(r)).join('\n')}
    }),`;
} _%>
<%_ relationships.filter(r => r.ownerSide).forEach(r => {
    if (r.relationshipType === 'many-to-many') { _%>
    <%= r.relationshipNamePlural %>: [],
    <%_ } else { _%>
<%- generateRelationshipForm(r) -%>
    <%_ }
}) _%>
    });

    constructor(
<%_ if (fieldsContainBlob) { _%>
        protected dataUtils: DataUtils,
<%_ } _%>
<%_ if (fieldsContainBlob || hasRelationshipQuery) { _%>
        protected messageService: MessageService,
<%_ } _%>
        protected <%= entityInstance %>Service: <%= entityAngularName %>Service,
<%_
Object.keys(differentRelationships).forEach(key => {
    if (differentRelationships[key].some(rel => rel.relationshipType === 'many-to-one' || rel.relationshipType === 'one-to-one' && rel.ownerSide === true || rel.relationshipType === 'many-to-many' && rel.ownerSide === true)) {
        const uniqueRel = differentRelationships[key][0];
        if (uniqueRel.otherEntityAngularName !== entityAngularName) {
_%>
        protected <%= uniqueRel.otherEntityName %>Service: <%= uniqueRel.otherEntityAngularName %>Service,
<%_ function generateConstructorImports(relationship) {
        return `protected ${relationship.otherEntityName}Service: ${relationship.otherEntityAngularName}Service,
        ${relationship.otherEntity.relationships.filter(r => r.id).map(r => generateConstructorImports(r)).join('')}`;
} _%>
<%_ uniqueRel.otherEntity.relationships.filter(r => r.id).map(r => {_%>
     <%- generateConstructorImports(r) -%>
<%_ }) _%>
<%_
        }
    }
}) _%>
        protected activatedRoute: ActivatedRoute,
        private fb: FormBuilder
    ) {
    }

    ngOnInit(): void {
        this.isSaving = false;
<%_ function generate(relationshipParent, relationshipSon) {
    return `this.${relationshipSon.relationshipName}Form.get('${relationshipSon.otherEntity.primaryKey.ids[0].name}')!.valueChanges.pipe(
      takeUntil(this.onDestroySubject),
      filter(() => !this.edit), // because we always subscribe even if not edit
      switchMap(${relationshipSon.otherEntity.primaryKey.ids[0].name} => {
        if (!${relationshipSon.otherEntity.primaryKey.ids[0].name}) {
          return of(undefined);
        }
        return this.${_.lowerFirst(relationshipParent.otherEntity.name)}Service.query({'${relationshipSon.relationshipName}.${relationshipSon.otherEntity.primaryKey.ids[0].name}.equals': ${relationshipSon.otherEntity.primaryKey.ids[0].name}}).pipe(
          map((res: HttpResponse<I${relationshipParent.otherEntity.name}[]>) => res.body!),
          catchError(err => {
            this.onError(err.message);
            return of(undefined);
          })
        )}),
    ).subscribe((${relationshipParent.relationshipName}Options?: I${relationshipParent.otherEntity.name}[]) => {
      this.${relationshipParent.relationshipName}Options = skillOptions;
      this.${relationshipParent.relationshipName}Form.get('${relationshipParent.otherEntity.primaryKey.ids[0].name}')!.reset();
    });

    ${relationshipSon.otherEntity.relationships.filter(r => r.id).map(r => generate(relationshipSon, r)).join('')}`;
} _%>
<%_ relationships.filter(r => r.ownerSide).forEach(r => {
    r.otherEntity.relationships.filter(rel => rel.id).forEach(rel =>  { _%>
    <%- generate(r,rel) -%>
<%_ });
})_%>
        this.activatedRoute.data.subscribe(({<%= entityInstance %>}) => {
            this.updateForm(<%= entityInstance %>);
        });
<%_ for (idx in relationships) { _%>
    <%_ if (relationships[idx].ownerSide) { _%>
        <%_ if (relationships[idx].pagination == 'no') { _%>
        this.loadAll<%= relationships[idx].relationshipNameCapitalizedPlural %>();
        <%_ } _%>
    <%_ } _%>
<%_ } _%>
    }

<%_ function generateForms(relationship, formName) {
    return `get ${relationship.relationshipName}Form(): FormGroup {
    return this.${formName}.get('${relationship.relationshipName}')! as FormGroup;
    }

    ${relationship.otherEntity.relationships.filter(r => r.id).map(r => generateForms(r, `${relationship.relationshipName}Form`)).join('')}`;
} _%>
<%_ relationships.filter(r => r.ownerSide).forEach(r => { _%>
    <%- generateForms(r, "editForm") -%>
<%_ }) _%>

<%_ function generateQueryParams(relationship) {
        if(!relationship.otherEntity.primaryKey.composite) {
             return `lazyLoadEventToServerQueryParams(event, 'globalFilter')`;
        } else {
           return `{...lazyLoadEventToServerQueryParams(event, 'globalFilter'),
            ${relationship.otherEntity.relationships.filter(r => r.id).map(r =>
                   r.otherEntity.primaryKey.ids.map(id => `'${r.relationshipName}.${id.nameDotted}.equals': this.${r.relationshipName}Form.value.${id.nameDotted}`)
           ).join(',\n')}
            }`
        }
} _%>

<%_ function generateRelationshipOnLazyLoadEvent(relationship) {
    return `on${_.upperFirst(relationship.relationshipName)}LazyLoadEvent(event: LazyLoadEvent): void {
        this.${_.lowerFirst(relationship.otherEntity.name)}Service.query(${generateQueryParams(relationship)})
            .subscribe((res: HttpResponse<I${relationship.otherEntity.name}[]>) => this.${relationship.relationshipName}Options = res.body, (res: HttpErrorResponse) => this.onError(res.message));
    }

    ${relationship.otherEntity.relationships.filter(r => r.id).map(r => generateRelationshipOnLazyLoadEvent(r)).join('\n')}`;
} _%>

<%_ for (idx in relationships) { _%>
    <%_ if (relationships[idx].ownerSide) { _%>
            <%_ if (relationships[idx].pagination == 'no') { _%>

    loadAll<%= _.upperFirst(pluralize(relationships[idx].relationshipName)) %>(): void {
                <%_ if (relationships[idx].relationshipType === 'one-to-one' && relationships[idx].ownerSide === true && relationships[idx].jpaMetamodelFiltering) { _%>
        //TODO change this to load only unspecified + add selectedTo options if any
                <%_ } _%>
        this.<%= _.lowerFirst(relationships[idx].otherEntity.name) %>Service.query()
            .subscribe((res: HttpResponse<I<%= relationships[idx].otherEntity.name %>[]>) => this.<%= relationships[idx].relationshipName %>Options = res.body, (res: HttpErrorResponse) => this.onError(res.message));
    }
            <%_ } else { _%>
    <%- generateRelationshipOnLazyLoadEvent(relationships[idx]) -%>
            <%_ } _%>
    <%_ } _%>
<%_ } _%>

    updateForm(<%= entityInstance %>: I<%= entityAngularName %> | null): void {
        if (<%= entityInstance %>) {
<%_ if (!entity.primaryKey.ids[0].autoGenerated || entity.primaryKey.derived) {_%>
            this.edit = true;
<%_ } _%>
            this.editForm.reset({ ...<%= entityInstance %> });
<%_ for (idx in fields) {
    const fieldName = fields[idx].fieldName;
    const fieldType = fields[idx].fieldType;
    const fieldTypeBlobContent = fields[idx].fieldTypeBlobContent;
_%>
    <%_ if (['byte[]', 'ByteBuffer'].includes(fieldType) && fieldTypeBlobContent !== 'text') { _%>
            if (<%= entityInstance %>.<%= fieldName %>) {
                fetch(`data:${<%= entityInstance %>.<%= fieldName %>ContentType!};base64,${<%= entityInstance %>.<%= fieldName %>}`)
                    .then((res: any) => res.blob() as string)
                    .then(blob => {
                        this.<%= fieldName %>File = new File([blob], '', {type: <%= entityInstance %>.<%= fieldName %>ContentType});
                    });
            }
    <%_ } _%>
<%_ } _%>
        } else {
<%_ if (!entity.primaryKey.ids[0].autoGenerated || entity.primaryKey.derived) { _%>
            this.edit = false;
<%_ } _%>
            this.editForm.reset({
<%_ for (idx in fields) { _%>
    <%_ if (fields[idx].fieldType === 'Boolean') { _%>
                <%= fields[idx].fieldName %>: false,
    <%_ } else if ( ['Instant', 'ZonedDateTime', 'LocalDate'].includes(fields[idx].fieldType) ) { _%>
                <%= fields[idx].fieldName %>: new Date(),
    <%_ } _%>
<%_ } _%>
            });
        }
    }

<%_ if (fieldsContainBlob) { _%>
    onFileSelect(event: {event: Event, files: File[]}, field: string): void {
        const file = event.files[0];
        this.dataUtils.toBase64(file, (base64Data: string) => {
            this.editForm.patchValue({
                [field]: base64Data,
                [field + 'ContentType']: file.type
            });
        });
    }

    onFileRemove(event: {event: Event, files: File[]}, field: string): void {
        this.editForm.patchValue({
            [field]: null,
            [field + 'ContentType']: null,
        });
    }

<%_ } _%>
    previousState(): void {
        window.history.back();
    }

    save(): void {
        this.isSaving = true;
        const <%= entityInstance %> = this.editForm.value;
    <%_ if (entity.primaryKey.ids[0].autoGenerated) { _%>
        if (<%= entityInstance %>.<%= primaryKey.name %> !== null) {
        <%_ } else { _%>
        if (this.edit) {
    <%_ } _%>
            this.subscribeToSaveResponse(this.<%= entityInstance %>Service.update(<%= entityInstance %>));
        } else {
            this.subscribeToSaveResponse(this.<%= entityInstance %>Service.create(<%= entityInstance %>));
        }
    }

    protected subscribeToSaveResponse(result: Observable<HttpResponse<I<%= entityAngularName %>>>): void {
        result.subscribe(() => this.onSaveSuccess(), () => this.onSaveError());
    }

    protected onSaveSuccess(): void {
        this.isSaving = false;
        this.previousState();
    }

    protected onSaveError(): void {
        this.isSaving = false;
    }

<%_ if (fieldsContainBlob || hasRelationshipQuery) { _%>
    protected onError(errorMessage: string): void {
        this.messageService.add({severity:'error', summary: errorMessage});
    }
<%_ } _%>
}

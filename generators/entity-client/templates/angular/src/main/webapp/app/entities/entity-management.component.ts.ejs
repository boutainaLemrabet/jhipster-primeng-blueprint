<%#
 Copyright 2013-2020 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%>
import { Component, OnInit, OnDestroy, ViewChild } from '@angular/core';
import { HttpErrorResponse, <%_ if (pagination !== 'no') { _%>HttpHeaders, <% } %>HttpResponse } from '@angular/common/http';
<%_ if (pagination === 'pagination' || pagination === 'pager') { _%>
import { ActivatedRoute, Router } from '@angular/router';
<%_ } else if (searchEngine !== false) { _%>
import { ActivatedRoute } from '@angular/router';
<%_ } _%>
import { Subscription } from 'rxjs';
import { filter<% if (pagination !== 'no') { %>, tap, switchMap<% } else { %>, map<% } %> } from 'rxjs/operators';
import { JhiEventManager<% if (fieldsContainBlob) { %>, JhiDataUtils<% } %> } from 'ng-jhipster';
import { FilterMetadata, MessageService } from 'primeng/api';
import { I<%= entityAngularName %> } from '../../shared/model/<%= entityModelFileName %>.model';
<%_
if ( jpaMetamodelFiltering) {
    const enumOptions = [];
    fields.forEach(field => {
        if (field.fieldIsEnum && !enumOptions.includes(field.fieldType)) {
            enumOptions.push(field.fieldType);
        }
    });
    enumOptions.forEach(e => { _%>
import { <%= e %>, <%= _.snakeCase(e).toUpperCase() %>_ARRAY } from '../../shared/model/enumerations/<%= _.kebabCase(e) %>.model';
    <%_ }); _%>
<%_ } _%>
import { <%= entityAngularName %>Service } from './<%= entityFileName %>.service';
<%_ if (pagination !== 'no') { %>
import { ITEMS_PER_PAGE } from '../../core/config/pagination.constants';
<%_ } _%>
<%_ if (pagination !== 'no' || relationships.some(r => r.ownerSide && r.pagination !== null)) { _%>
import { lazyLoadEventToServerQueryParams<% if (pagination !== 'no') {%>, lazyLoadEventToRouterQueryParams, fillTableFromQueryParams<% } %> } from '../../core/request/request-util';
<%_ } _%>
import { ConfirmationService<%_ if (pagination !== 'no' || relationships.some(r => r.ownerSide && r.pagination !== null)) { _%>, LazyLoadEvent<% } %> } from 'primeng/api';
import { TranslateService } from '@ngx-translate/core';
<%_ function generateRelationshipsImports(relationship) {
    return `${relationship.otherEntity.relationships.filter(r => r.id).map(r => generateRelationshipsImports(r)).join('')}
    import { I${relationship.otherEntityAngularName} } from '../../shared/model/${relationship.otherEntityFileName}.model';
    import { ${relationship.otherEntityAngularName}Service } from '../../entities/${relationship.otherEntityFolderName}/${relationship.otherEntityFileName}.service';`;

} _%>
<%_ if(jpaMetamodelFiltering){ _%>
    <%_ const alreadyImported = new Set()
    alreadyImported.add(entity.name)%>
    <%_ for (idx in relationships) {
        const relationshipType = relationships[idx].relationshipType;
        const ownerSide = relationships[idx].ownerSide;
    if (relationshipType === 'many-to-one'
            || (relationshipType === 'one-to-one' && ownerSide === true)
            || (relationshipType === 'many-to-many' && ownerSide === true && pagination === 'no')) { _%>
                <%_ if(!alreadyImported.has(relationships[idx].otherEntity.name)) { _%>
                    <%_ alreadyImported.add(relationships[idx].otherEntity.name); _%>
                    <%_ if(relationships[idx].otherEntity.name === 'User') { _%>
import { IUser } from '../../core/user/user.model';
import { UserService } from '../../core/user/user.service';
                    <%_ } else {_%>
<%- generateRelationshipsImports(relationships[idx])-%>
                    <%_ } _%>
                <%_ } _%>
        <%_ } _%>
    <%_ } _%>
<%_ } _%>
import { Table } from 'primeng/table';
<%_ if(jpaMetamodelFiltering && fields.some(f => ['LocalDate', 'Instant', 'ZonedDateTime'].includes(f.fieldType))){ _%>
import { DatePipe } from '@angular/common';
<%_ } _%>

@Component({
    selector: '<%= jhiPrefixDashed %>-<%= entityFileName %>',
    templateUrl: './<%= entityFileName %>.component.html'
})

export class <%= entityAngularName %>Component implements OnInit, OnDestroy {
    <%= entityInstancePlural %>?: I<%= entityAngularName %>[];
    eventSubscriber?: Subscription;
<%_ function generateOptions(relationship) {
        return `${relationship.relationshipName}Options: I${relationship.otherEntity.name}[] | null = null;
        ${relationship.otherEntity.relationships.filter(r => r.id).map(r => generateOptions(r)).join('')}`;
} _%>
<%_ if (jpaMetamodelFiltering) {
    for (idx in fields) {
        if(['LocalDate', 'Instant', 'ZonedDateTime'].includes(fields[idx].fieldType)){ _%>
            <%_ if (pagination !== 'no') { _%>
    <%= fields[idx].fieldName %>Range?: Date[];
            <%_ } _%>
        <%_ } else if(fields[idx].fieldIsEnum) {_%>
    <%= fields[idx].fieldName %>Options = <%= _.snakeCase(fields[idx].fieldType).toUpperCase() %>_ARRAY.map((s: <%=fields[idx].fieldType%>) => ({ label: s.toString(), value: s }));
        <%_ } _%>
    <%_ } _%>
    <%_ for (idx in relationships) {
        const relationshipType = relationships[idx].relationshipType;
        const ownerSide = relationships[idx].ownerSide;
        if (relationshipType === 'many-to-one'
            || (relationshipType === 'one-to-one' && ownerSide === true)
            || (relationshipType === 'many-to-many' && ownerSide === true && pagination === 'no')) { _%>
<%- generateOptions(relationships[idx]) -%>
        <%_ } _%>
    <%_ } %>
<%_ } _%>
<%_ if (pagination !== 'no') { _%>
    totalItems?: number;
    itemsPerPage!: number;
    loading!: boolean;

<%_ } _%>
    private filtersDetails: { [_: string]: { matchMode?: string; flatten?: (_: string[]) => string; unflatten?: (_: string) => any } } = {
<%_ for ( idx in fields ) {
    if (fields[idx].fieldIsEnum) { _%>
        <%= fields[idx].fieldName %>: {matchMode: 'in'},
    <%_ } else if (fields[idx].fieldType === 'String') { _%>
        <%= fields[idx].fieldName %>: {matchMode: 'contains'},
    <%_ } else if (['LocalDate', 'Instant', 'ZonedDateTime'].includes(fields[idx].fieldType)) { _%>
        <%= fields[idx].fieldName %>: {matchMode: 'between', flatten: a => a.filter((x: string) => x).join(','), unflatten: (a: string) => a.split(',') },
    <%_ } else if (fields[idx].fieldType === 'Boolean') { _%>
        <%= fields[idx].fieldName %>: {matchMode: 'equals', unflatten: (x: string) => x === 'true'},
    <%_ } else if (['Integer', 'Long', 'Float', 'Double', 'BigDecimal', 'Duration'].includes(fields[idx].fieldType)) {  _%>
        <%= fields[idx].fieldName %>: {matchMode: 'equals', unflatten: (x: string) => +x},
    <%_ } _%>
<%_ } _%>
<%_ for ( idx in relationships ) {
    const relationshipType = relationships[idx].relationshipType;
    const ownerSide = relationships[idx].ownerSide;
    if (relationshipType === 'many-to-one'
        || (relationshipType === 'one-to-one' && ownerSide === true)
        || (relationshipType === 'many-to-many' && ownerSide === true && pagination === 'no')) { _%>
        <%_ relationships[idx].otherEntity.primaryKey.ids.forEach(pk => { _%>
        ['<%= relationships[idx].relationshipFieldName %>.<%= pk.nameDotted %>']: {matchMode: 'in'<% if(['Integer', 'Long', 'Float', 'Double', 'BigDecimal', 'Duration'].includes(pk.field.fieldType)) { %>, flatten: a => a.filter((x: string) => `${x}`).join(','), unflatten: (a: string) => a.split(',').map(x => +x) <% } %><% if(pk.field.fieldType === 'String') { %>, flatten: a => a.filter((x: string) => x).join(','), unflatten: (a: string) => a.split(',') <% } %>},
        <%_ }) _%>
    <%_ } _%>
<%_ } _%>
    };

    @ViewChild('<%= entityInstance %>Table', { static: true })
    <%= entityInstance %>Table!: Table;

    constructor(
        protected <%= entityInstance %>Service: <%= entityAngularName %>Service,
<%_ function generateConstructorElements(relationship) {
    return `protected ${_.lowerFirst(relationship.otherEntity.name)}Service: ${relationship.otherEntity.name}Service,
    ${relationship.otherEntity.relationships.filter(r => r.id).map(r => generateConstructorElements(r)).join('')}`;
}_%>
<%_ if(jpaMetamodelFiltering){ _%>
    <%_ const alreadyInConstructor = new Set()
    alreadyInConstructor.add(entity.name)_%>
    <%_ for (idx in relationships) {
        const relationshipType = relationships[idx].relationshipType;
        const ownerSide = relationships[idx].ownerSide;
    if (relationshipType === 'many-to-one'
            || (relationshipType === 'one-to-one' && ownerSide === true)
            || (relationshipType === 'many-to-many' && ownerSide === true && pagination === 'no')) { _%>
                <%_ if(!alreadyInConstructor.has(relationships[idx].otherEntity.name)) { _%>
                    <%_ alreadyInConstructor.add(relationships[idx].otherEntity.name); _%>
        <%- generateConstructorElements(relationships[idx]) -%>
                <%_ } _%>
        <%_ } _%>
    <%_ } _%>
<%_ } _%>
        protected messageService: MessageService,
        <%_ if (fieldsContainBlob) { _%>
        protected dataUtils: JhiDataUtils,
        <%_ } _%>
<%_ if (pagination !== 'no') { _%>
        protected activatedRoute: ActivatedRoute,
        protected router: Router,
<%_ } _%>
        protected eventManager: JhiEventManager,
<%_ if (!readOnly) { _%>
        protected confirmationService: ConfirmationService,
<%_ } _%>
        protected translateService: TranslateService,
        <%_ if(jpaMetamodelFiltering && fields.some(f => ['LocalDate', 'Instant', 'ZonedDateTime'].includes(f.fieldType))){ _%>
        protected datePipe: DatePipe,
        <%_ } _%>
    ) {
        <%_ if (pagination !== 'no') { _%>
        this.itemsPerPage = ITEMS_PER_PAGE;
        this.loading = true;
        <%_ } _%>
        <%_ if (searchEngine === 'elasticsearch') { _%>
        this.currentSearch = this.activatedRoute.snapshot && this.activatedRoute.snapshot.params['search'] ?
            this.activatedRoute.snapshot.params['search'] : '';
        <%_ } _%>
    }

    ngOnInit(): void {
<%_ if (pagination === 'no') { %>
        this.loadAll();
<%_ } _%>
<%_ if(jpaMetamodelFiltering){ _%>
    <%_ for (idx in relationships) { _%>
        <%_ if (relationships[idx].ownerSide && relationships[idx].pagination == 'no') { _%>
            <%_ relationships[idx].otherEntity.primaryKey.ids.forEach(pk => { _%>
        this.loadAll<%= _.upperFirst(pluralize(pk.entity.name)) %>();
            <%_ }) _%>
        <%_ } _%>
    <%_ } _%>
<%_ } _%>
        this.registerChangeIn<%= entityClassPlural %>();
<%_ if (pagination !== 'no') { _%>
        this.activatedRoute.queryParams.pipe(
            tap(queryParams => fillTableFromQueryParams(this.<%= entityInstance %>Table, queryParams, this.filtersDetails)),
    <%_ for ( idx in fields ) {
        if (['LocalDate', 'Instant', 'ZonedDateTime'].includes(fields[idx].fieldType)) { _%>
            tap(() => (this.filters.<%= fields[idx].fieldName %>?.value?.map((x: string) => new Date(x)) as Date[])),
        <%_ } _%>
    <%_ } _%>
            tap(() => this.loading = true),
        <%_ if (searchEngine === 'elasticsearch') { _%>
            switchMap(() => {
                if (this.currentSearch) {
                    this.<%= entityInstance %>Service.search(this.<%= entityInstance %>Table.filters.global.value)
                } else {
                    return this.<%= entityInstance %>Service.query(lazyLoadEventToServerQueryParams(this.<%= entityInstance %>Table.createLazyLoadMetadata()));
                }
            }),
        <%_ } else { _%>
            switchMap(() => this.<%= entityInstance %>Service.query(lazyLoadEventToServerQueryParams(this.<%= entityInstance %>Table.createLazyLoadMetadata()))),
        <%_ } _%>
            filter((res: HttpResponse<I<%= entityAngularName %>[]>) => res.ok)
        ).subscribe(
            (res: HttpResponse<I<%= entityAngularName %>[]>) => {
                this.paginate<%= entityClassPlural %>(res.body!, res.headers);
                this.loading = false;
            },
            (res: HttpErrorResponse) => {
                this.onError(res.message);
                this.loading = false;
            }
        );
<%_ } _%>
    }

    get filters(): { [s: string]: FilterMetadata } {
        return this.<%= entityInstance %>Table.filters as { [s: string]: FilterMetadata };
    }

    ngOnDestroy(): void {
        if (this.eventSubscriber) {
            this.eventManager.destroy(this.eventSubscriber);
        }
    }

    <%_ if (pagination === 'no') {  _%>
    loadAll(): void {
        <%_ if (searchEngine === 'elasticsearch') { _%>
        if (this.currentSearch) {
            this.<%= entityInstance %>Service.search({
                query: this.currentSearch,
                }).pipe(
                    filter((res: HttpResponse<I<%= entityAngularName %>[]>) => res.ok),
                    map((res: HttpResponse<I<%= entityAngularName %>[]>) => res.body),
                ).subscribe(
                    (res: I<%= entityAngularName %>[]) => this.<%= entityInstancePlural %> = res,
                    (res: HttpErrorResponse) => this.onError(res.message)
                );
            return;
        }
        <%_ } _%>
        this.<%= entityInstance %>Service.query().pipe(
            filter((res: HttpResponse<I<%= entityAngularName %>[]>) => res.ok),
            map((res: HttpResponse<I<%= entityAngularName %>[]>) => res.body!),
        ).subscribe(
            (<%= entityInstancePlural %>: I<%= entityAngularName %>[]) => {
                this.<%= entityInstancePlural %> = <%= entityInstancePlural %>;
            <%_ if (searchEngine === 'elasticsearch') { _%>
                this.currentSearch = '';
            <%_ } _%>
            },
            (res: HttpErrorResponse) => this.onError(res.message)
        );
    }
    <%_ } else { _%>
    onLazyLoadEvent(event: LazyLoadEvent): void {
        const queryParams = lazyLoadEventToRouterQueryParams(event, this.filtersDetails);
        this.router.navigate(['/<%= entityUrl %>'], { queryParams });
    }
    <%_ } _%>

    filter(value: any, field: string): void {
        this.<%= entityInstance %>Table.filter(value, field, this.filtersDetails[field].matchMode!);
    }
<%_ if (!readOnly) { _%>

    delete(<%= primaryKey.ids.map(pk => `${pk.name}: ${this.getTypescriptKeyType(pk.field.fieldType)}`).join(', ') %>): void {
        this.confirmationService.confirm({
            header: this.translateService.instant('entity.delete.title'),
            message: this.translateService.instant('<%= i18nKeyPrefix %>.delete.question',
    { id<%- (primaryKey.ids.length === 1 && primaryKey.ids[0].name === 'id') ? '' : ': `' + primaryKey.ids.map(pk => '${'+pk.name+'}').join(" , ") + '`' %> }),
            accept: () => {
                this.<%= entityInstance %>Service.delete(<%= primaryKey.ids.map(pk => `${pk.name}`).join(', ') %>).subscribe(() => {
                    this.eventManager.broadcast({
                        name: '<%= entityInstance %>ListModification',
                        content: 'Deleted an <%= entityInstance %>'
                    });
                });
            }
        });
    }
<%_ } _%>
    <%_ if(jpaMetamodelFiltering) { _%>
    <%_ function generateOnLazyLoadEvent(relationship)  {
        return `on${_.upperFirst(relationship.relationshipName)}LazyLoadEvent(event: LazyLoadEvent): void {
        this.${_.lowerFirst(relationship.otherEntity.name)}Service.query(lazyLoadEventToServerQueryParams(event, 'globalFilter'))
            .subscribe(res => this.${relationship.relationshipName}Options = res.body);
        }

        ${relationship.otherEntity.relationships.filter(r => r.id).map(r => generateOnLazyLoadEvent(r)).join('')}`;
    }_%>
        <%_ for (idx in relationships) {
            const relationshipType = relationships[idx].relationshipType;
            const ownerSide = relationships[idx].ownerSide;
            if (relationshipType === 'many-to-one'
                    || (relationshipType === 'one-to-one' && ownerSide === true)
                    || (relationshipType === 'many-to-many' && ownerSide === true && pagination === 'no')) { _%>
                <%_ if (relationships[idx].pagination == 'no') { _%>

        loadAll<%= _.upperFirst(pluralize(relationships[idx].otherEntity.name)) %>(): void {
            this.<%= _.lowerFirst(relationships[idx].otherEntity.name) %>Service.query()
                .subscribe(res => this.<%= relationships[idx].otherEntity.name %>Options = res.body);
        }
                <%_ } else {_%>

        <%- generateOnLazyLoadEvent(relationships[idx]) -%>
                 <%_ } _%>
            <%_ } _%>
        <%_ } _%>
    <%_ } _%>

    trackId(index: number, item: I<%= entityAngularName %>): <%= tsKeyType %> {
<%_ if (primaryKey.ids.length === 1) {
    // splitting cases to avoid converting number keys to string and having useless `
_%>
        return item.<%= primaryKey.name %>!;
<%_ } else { _%>
        return `<%- entity.primaryKey.ids.map(pk => `\${item.${pk.nameDottedAsserted}}`).join(",")%>`;
<%_ } _%>
    }

    <%_ if (fieldsContainBlob) { _%>

    byteSize(field: string): string {
        return this.dataUtils.byteSize(field);
    }

    openFile(contentType = '', field: string): void {
        return this.dataUtils.openFile(contentType, field);
    }
    <%_ } _%>

    <%_
    let eventCallBack = 'this.loadAll()';
    if (pagination !== 'no') {
        eventCallBack = "this.router.navigate(['/" + entityUrl + "'], {queryParams: {r: Date.now()}})";
    }
    _%>

    registerChangeIn<%= entityClassPlural %>(): void {
        this.eventSubscriber = this.eventManager.subscribe('<%= entityInstance %>ListModification', () =>
            <%- eventCallBack %>
        );
    }

    <%_ if (pagination !== 'no') { _%>
        <%_ if (pagination === 'pagination' || pagination === 'pager') { _%>

    protected paginate<%= entityClassPlural %>(data: I<%= entityAngularName %>[], headers: HttpHeaders): void {
        <%_ if (databaseType !== 'cassandra') { _%>
        this.totalItems = Number(headers.get('X-Total-Count'));
                    <%_ } _%>
        this.<%= entityInstancePlural %> = data;
    }

    <%_ } else if (pagination === 'infinite-scroll') { _%>

    protected paginate<%= entityClassPlural %>(data: I<%= entityAngularName %>[], headers: HttpHeaders): void {
        this.totalItems = Number(headers.get('X-Total-Count'));
        for (let i = 0; i < data.length; i++) {
            this.<%= entityInstancePlural %>.push(data[i]);
        }
    }
    <%_ }} _%>

    protected onError(errorMessage: string): void {
        this.messageService.add({severity:'error', summary: errorMessage});
    }
    <%_ if(pagination !== 'no' && jpaMetamodelFiltering && fields.some(f => ['LocalDate', 'Instant', 'ZonedDateTime'].includes(f.fieldType) )){ _%>

    onDateSelect(dateRange: Date[] | undefined, column: string, time = false): void {
        const dateToString =  time ? ((x: Date) => x.toISOString()) : ((x: Date) => this.datePipe.transform(x, 'yyyy-MM-dd'));
        if (dateRange) {
            this.filter(dateRange.map(dateToString), column);
        } else {
            this.filter(undefined, column);
        }
    }
    <%_ } _%>
}
